import Page from '@reason/pages/Docs';
export default Page({title: "Snarky DSL Guide"});

Здесь вы можете найти документацию по использованию **snarky**, DSL для использования zk-SNARKS, а также **snarkyjs-crypto** (сопутствующей библиотеки JavaScript, предоставляющей набор криптографических примитивов, подходящих для использования с **snarky**).


## Структура SNAPP

SNAPP (или SNARK-приложение) состоит из двух частей:

1. Определение вашей программы zk-SNARK. Эта часть будет построена с использованием **snarky**
   и прежде всего стандартной библиотеки [snarky-universe](/docs/snarks/snarky-universe).
2. Остальная часть приложения, которое вызывает **snarky** для создания и проверки доказательств.
   В настоящее время существуют API для Node.js и OCaml/ReasonML для взаимодействия с программами **snarky** таким образом.

    Мы используем две библиотеки Node.js:

    - [snarkyjs-crypto](/docs/snarks/snarkyjs-crypto), что дает нам доступ
      к криптографическим хэшам, деревьям Меркла и подписям, которые зеркально отражают то, что есть в snarky-universe.
    - [snarkyjs](https://www.npmjs.com/package/snarkyjs), который дает нам методы для создания и проверки SNARK-доказательств.

## Пример приложения

Давайте создадим простое приложение для доказательства того, что мы знаем предварительную картинку хэш-функции.
Готовое приложение вы можете найти [здесь](https://github.com/o1-labs/sfbw-workshop/tree/master/solutions/ex_preimage).

### Строительство SNARK

Первым шагом в построении SNAPP является определение нашего SNARK. В этом случае, наш SNARK
докажет, применив значение хэша **h**

> Я знаю элемент поля **x** таким образом, чтобы **hash(x) = h**.

where **hash** is the Poseidon hash function provided in snarky-universe.

The snarky component -- [defined in this file](https://github.com/o1-labs/sfbw-workshop/blob/master/solutions/ex_preimage/ex_preimage.re) -- is as follows:

```reasonml
module Universe = (val Snarky_universe.default());
open! Universe.Impl;
open! Universe;

let input = InputSpec.[(module Hash)];

module Witness = Field;

let main = (preimage: Witness.t, h, ()) =>
  Field.assertEqual(Hash.hash([|preimage|]), h);

runMain(input, (module Witness), main);
```

Let's break down this file bit by bit. The top 3 lines
```reasonml
module Universe = (val Snarky_universe.default());
open! Universe.Impl;
open! Universe;
```
are just a preamble which brings in scope all the functions we need. It uses the "default" SNARK construction backend,
which is the Groth16 SNARK instantiated using the bn128 curve.

The next line
```reasonml
let input = InputSpec.[(module Hash)];
```
declares that the public input to our SNARK will be a hash. The "public input" (or "statement") is the value that our
SNARK is checked against.

The next line
```reasonml
module Witness = Field;
```
states that our top-level "witness" (that is, the thing we're proving we know) will be a single field element,
as described above.

Next, we have the `main` function, which really defines our SNARK
```reasonml
let main = (preimage: Witness.t, h, ()) =>
  Field.assertEqual(Hash.hash([|preimage|]), h);
```

Here we write just what we described above: `main` computes the hash of the witness and asserts that it is
equal to the public input `h`.

The arguments to `main` must be

1. The top level witness value.
2. Any public inputs. Here we just have one, `h`.
3. A dummy `()` argument.

The final line
```reasonml
runMain(input, (module Witness), main);
```
sets up our program to work with the Node.js API.

### Using the SNARK
Now we're ready to use our SNARK. We're going to use the Node.js API.

The API is fairly straightforward. We can create a "snarky" object which has 2 methods:

1. `prove`, which takes a statement and a witness and returns a promise of a proof.
2. `verify`, which takes a statement and a proof and returns a promise of a bool.

Here is how it all comes together:

```javascript
const { bn128 } = require('snarkyjs-crypto');
const Snarky = require('snarkyjs');
const snarky = new Snarky("./ex_preimage.exe");

const preImage = bn128.Field.ofInt(5);
const statement = bn128.Hash.hash([ preImage ]);

snarky.prove({
  statement: [ statement ],
  witness: preImage
}).then((proof) => {
  console.log("Created proof:\n" + proof + "\n");
  return snarky.verify({
    "statement": [ statement ],
    "proof": proof
  });
}, console.log).then((verified) => {
  console.log("Was the proof verified? " + verified);
  if (verified) {
    process.exit(0);
  } else {
    process.exit(1);
  }
}, () => { process.exit(1); });
```

