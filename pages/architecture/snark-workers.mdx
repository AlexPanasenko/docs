import Page from "@reason/pages/Docs";
export default Page({ title: "Snark Workers for Node Operators" });

## Введение

В то время как большинство протоколов имеют только одну основную группу нод-операторов (часто называемых майнерами, валидаторами или блок-продюсерами), у Mina есть вторая группа — **snark worker**.

Снарк-воркеры являются неотъемлемой частью здоровья сети Mina, потому что именно эти узлы отвечают за "снаркинг" - производство SNARK-доказательств, связанных с транзакциями в сети. Производя эти доказательства, снарк-воркеры помогают поддерживать компактность блокчейн Mina.

В этом документе мы вкратце расскажем о том, зачем нужны снарк-воркеры, как выстраиваются экономические стимулы, а также опишем операционные детали выполнения снарк-работы. Кликните на любой из вышеперечисленных разделов, который наиболее соответствует вашим интересам.

Примечание: этот документ в первую очередь ориентирован на операторов нод и не будет охватывать теорию zk-SNARK. Глубокое знание теории SNARK не требуется для прочтения этого раздела. Но вам будет полезно приблизительно знать, как работают SNARK и для чего они используются. Пожалуйста, обратите внимание на [этот учебник по SNARK] в первую очередь.(https://minaprotocol.com/blog/what-are-zk-snarks)

## Почему Снарк-воркеры?

Уникальным свойством Mina является компактный блокчейн. Каждый блок-продюсер, когда он предлагает сети новый блок, должен также включить в этот блок zk-SNARK. Это позволяет нодам отказываться от всех исторических данных, которые были завершены, сохраняя только SNARK. Если вы незнакомы с протоколом Mina, [это видео будет хорошим началом].(https://www.youtube.com/watch?v=eWVGATxEB6M).

Однако, блок-продюсерам Mina недостаточно только лишь создавать SNARK-доказательства блоков. Транзакции также должны cодержать снарки. Причина заключается в том, что сам блокчейн SNARK не делает каких-либо утверждений о валидности сделок, включенных в блок.

Например - допустим, текущий заголовок блокчейна имеет хэш состояния `a6f8792226...`, и мы получаем новый блок с хэшем `0ffdcf284f...` . Этот блок будет содержать все транзакции, которые блок-продюсер выбрал для включения в этот блок, а также связанные с ним метаданные. Мы также получим сопроводительный SNARK, подтверждающий правильность сообщения:

> "There exists a block with a state hash 0ffdcf284f which extends the blockchain
> with a previous best tip with state hash a6f8792226."

Обратите внимание, что в этом сообщении ничего не говорится о действительности сделок, включенных в новый блок. Если мы поверим этому SNARK и ничего больше не предпримем, нас может обмануть вредоносный блок-продюсер, посылающий этот блок. К счастью, у нас есть "сырой" блок, и мы можем проверить каждую сделку, чтобы убедиться, что она действительна. Но как насчет нод в сети, которые могут просто захотеть получить подтверждение без проверки каждого блока?

## Транзакции со SNARK

Чтобы гарантировать, что ноды могут работать на Mina без доверия, важно, чтобы каждая нода могла проверить состояние блокчейна без необходимости воспроизводить транзакции. Для того, чтобы это сработало, описанного выше блокчейна SNARK недостаточно. Нам необходимо знать, что транзакции также достоверны. Поскольку SNARK хороши именно для этого, то элементарным предложением может быть генерация SNARK для каждой транзакции по мере их поступления, а затем их объединение.

Однако генерация доказательств SNARK является дорогостоящей вычислительной процедурой - если бы нам приходилось вычислять SNARK последовательно для каждой транзакции, то пропускная способность была бы очень низкой, а время формирования блоков - стремительно возрастало бы. Более того, транзакции в реальных условиях поступают асинхронно, поэтому было бы очень сложно предсказать, когда будет выполняться следующий этап работы.

К счастью для нас, мы можем использовать два свойства SNARK:

1. доказательства могут быть совмещены - два доказательства могут быть объединены, чтобы сформировать _merge proof_
2. объединения сочетаемы - доказательства слияния идентичны, независимо от порядка их объединения

<picture>
  <source media="(min-width:48rem)" srcset="/static/img/docsImages/Documents_FAQFork_Tablet 1.jpg"/>
  <source media="(min-width:90rem)" srcset="/static/img/docsImages/Documents_SNARKS_p3-01 1.jpg" />
  <img src="/static/img/docsImages/Documents_FAQFork_Mobile 1.jpg" alt="Snark Workers"></img>
</picture>

What these two properties essentially allow us to do is take advantage of parallelism. If proofs can be merged, and it doesn't matter how they're combined, then SNARK proofs can be generated in parallel. Whichever proof is finished first can be combined later with the proofs in progress. This can be envisioned as a binary tree, where the bottom row (the leaves) consists of the individual transaction proofs, and each parent row, the set of respective merge proofs. We can combine these all the way to the root, which represents a state update performed by applying all the transactions.

In addition, because the SNARK proofs don't depend on each other and we can exploit parallelism, this means anyone can do the work! The end result is that the distributed work pool is permission-less. Anyone with spare compute can join the network as snark workers, observe transactions that need to be snarked, and contribute their compute. And of course, they will be compensated for their work in what we affectionately call **the snarketplace**.

Note: To learn more about the details of how this snark work scheme evolved, it is highly recommended to watch this video: [High Throughput with Slow Snarks](https://www.youtube.com/watch?v=NZmq1V-Te0E). If you're interested in functional programming and the details of the scan state (the tree structure described above), [we have a blog post](/blog/scanning-for-scans) covering the technical details, or [a video](https://www.youtube.com/watch?v=ztH_Z5TCe9I) if you prefer that format.

## The Snarketplace

The key dynamic to understand about snark work is:

_Block producers use their block rewards to purchase snark work from snark workers._

There is no protocol involvement in pricing snarks, nor are there any protocol level rewards for snark workers to produce snarks. The incentives are purely peer-to-peer, and dynamically established in a public marketplace, aka the snarketplace.

You may ask, why does a block producer need to buy SNARKs? Fair question — the reason is because of what we mentioned earlier. In order to know for sure the state at the head of the Mina blockchain is valid, the transactions need to be snarked. But if we keep adding more transactions without snarking them at an equal rate, then over time we accumulate work that never gets finished. In order to reach a steady state equilibrium, we need work to be processed at roughly the same rate that work is added.

Since block producers profit from including transactions in a block (through transaction fees and the coinbase transaction), they are responsible for offsetting the transactions by purchasing an equal number of completed snark work, thereby creating demand for snark work. However, their imperative is to purchase snark work for the lowest price from the snarketplace. Conversely, the snark workers want to maximize their profit while also being able to sell their snark work. These two roles act as the two sides of the marketplace, and over time establish an equilibrium at a market price for snark work.

### How to price snark work

We anticipate the snarketplace to dynamically rebalance — eg. follow the simple laws of [supply and demand](https://en.wikipedia.org/wiki/Supply_and_demand). While each snark work applies to a different transaction, seen from a larger perspective, snark work is largely a commodity (meaning it doesn't matter which snark worker produces the good — it will be the same). However, there are some nuances, so it may help to have some heuristics for pricing strategy:

- if market price is X, it is likely effective to sell snark work for any price below X (eg. X - 1), provided it is profitable after operating expenses.
- block producers are incentivized to purchase more units of snark work from the same snark worker because there will only be one _fee transfer_ transaction they have to include in the block.
  - Basically, the way a block producer pays a snark worker is through a special type of transaction called a fee transfer. The BP's incentive is to minimize the number of fee transfers, as each is a discrete transaction that needs to be added to a block (and consequently offset by more snark work). Thus, the best case scenario is to buy a bundle of snark work from the same snark worker.
- some snark work will be more important to complete ahead of other work, as it would free up an entire tree worth of memory (see the video above for more details). This is made possible by different work selection methods. Currently, the two methods supported natively are sequential and random. Neither of these however takes advantage of dynamic markets, which is an area of improvement that the Mina community can develop solutions for.

Since all the data around snarks and prices are public, there are several ways to inspect the snarketplace. One example is [using the GraphQL API](https://youtu.be/XQlfX-LnK_A), and other options include using the CLI, or rolling a custom solution that tracks snarks in the snark mempool.

Stay tuned for more detailed analysis on snarketplace dynamics. We will also be releasing an economic whitepaper shortly that will provide more context.

See also: [SNARKs and Snark Workers FAQ](/docs/faq#snarks-and-snark-workers)
