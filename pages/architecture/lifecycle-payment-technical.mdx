import Page from "@reason/pages/Docs";
export default Page({ title: "Lifecycle of a Payment Technical Guide" });

# Жизненный цикл платежа - Технический справочник

Платежи в Mina проходят через несколько этапов, прежде чем они считаются проверенными и завершенными. Этот документ предназначен для того, чтобы познакомиться с тем, что происходит с одним платежом, когда он проходит через кодовую базу. Если вы хотите понять, как платежи работают на макроскопическом уровне, доступен более высокий уровня обзора [жизненного цикла платежа] (/docs/architecture/lifecycle-payment).

Допустим, вы хотите отправить платеж в Mina (при условии, что вами ранее уже был создан счет и вы получили необходимые средства).
Ваш друг даёт вам свой публичный ключ -- это `KEFLx5TOqJNzd6buc+dW3HCjkL57NjnZIaplYJ50DO1uTfogKfwAAAAA`.

Затем вы вызываете следующую команду:

```bash
$ mina client send-payment \
    -amount 10 \
    -receiver KEFLx5TOqJNzd6buc+dW3HCjkL57NjnZIaplYJ50DO1uTfogKfwAAAAA \
    -fee 3 \
    -privkey-path keys/my-wallet
```

Где:

- `amount` это сумма mina, которую вы посылаете
- `receiver` это публичный ключ предполагаемого получателя
- `fee` это комиссия, которая должна быть оплачена сети за обработку транзакции.
- `privkey-path` это путь к файлу с закрытым ключом для вашего аккаунта.

## Клиент Mina 

Файл [client.ml](https://github.com/MinaProtocol/mina/tree/master/src/app/cli/src/client.ml) определяет парсер команд CLI для подкоманд `mina client`.
Мы часто используем стандартные библиотеки [Jane Street](https://github.com/janestreet).
В частности, очень часто используются [Core](https://opensource.janestreet.com/core/) (общие структуры данных) и [Async](https://opensource.janestreet.com/async/) (асинхронное программирование с использованием составного типа `Deferred.t`).
Поверх большинства файлов вы увидите какой-либо вариант `open Core` и `open Async`.
В [client.ml](https://github.com/minaprotocol/mina/tree/master/src/app/cli/src/client.ml) мы тоже это видим. `Async` затеняет тип `Command` и позволяет нам декларативно отразить детали каждой команды.
Если вы прокрутите вниз [client.ml](https://github.com/minaprotocol/mina/tree/master/src/app/cli/src/client.ml), вы увидите, что мы регистрируем команду `send-payment` в функции `send_payment`.
Здесь мы описываем флаги, от которых зависит это действие: `receiver` [публичного ключа](#public-key), комиссии, суммы и пути к вашему [приватному ключу](#private-key). Эти типы параметров флага определены в [daemon_rpcs.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/daemon_rpcs.ml).
В теле `send_payment` мы создаем платеж и пересылаем его [daemon](#daemon).

## Платеж

В [payment.mli](https://github.com/minaprotocol/mina/tree/master/src/lib/mina_base/payment.mli) вы увидите пару важных вещей. (1) мы разбиваем платежи на [платежную нагрузку](#payment-payload) (часть, которая должна быть [подписана](#signature)) и остальное. И (2) вы видите тип, который, хоть и определяется в странной манере, но является общим шаблоном в нашей кодовой базе.

См. более подробную информацию:

- [Параметризованные отчеты](/docs/developers/style-guide/#parameterized-records)
- [Ppx deriving](/docs/developers/style-guide/#ppx_deriving)
- [Stable.V1](/docs/developers/style-guide/#stable-v1)
- [Property based тесты](/docs/developers/style-guide/#quickcheck-gen)
- [Typesafe Invariants](/docs/developers/style-guide/#typesafe-invariants)
- [Unit Тесты](/docs/developers/style-guide/#unit-tests)

Давайте разберемся с платежной нагрузкой:

## Платежная нагрузка

Ознакомьтесь с разделом [payment_payload.mli](https://github.com/minaprotocol/mina/tree/master/src/lib/mina_base/payment_payload.mli). Напомним, что платежная нагрузка является частью платежа, который отправитель подпишет своим приватным ключом. Мы видим, что нагрузка строится из [публичного ключа](#public-key) получателя, [суммы](#currency), [комиссии](#currency), и [однократно используемого числа](#account-nonce). Опять же, полезная нагрузка содержит SNARK, поэтому она имеет `type var`, и другие важные функции со SNARK (в будущем RFC мы поместим это в пользовательскую [ppx_deriving](#ppx-deriving).


## Подписи

(TODO: @ihm can you correct any details I mess up here)

Мы используем [подписи Шнорра](https://en.wikipedia.org/wiki/Schnorr_signature). [Подпись Шнорра](https://en.wikipedia.org/wiki/Schnorr_signature) является элементом в [группе](https://en.wikipedia.org/wiki/Group_(mathematics). Наша группа - это точка на [эллиптической кривой](https://en.wikipedia.org/wiki/Elliptic_curve). Так что же такое подпись? Откройте [библиотеки подписи checked.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/signature_lib/checked.ml) и прокрутите до `module Signature` внутри `module type S`. Это ненулевая точка на кривой, также известная как пара двух значений `curve_scalar`. Для подписи мы даем [закрытый ключ](#private-key) и сообщение. Проверить подпись в сообщении можно с помощью [открытого ключа](#public-key).


Это первый раз, когда мы видим тяжело функторированный код, поэтому смотрите [функторы](/docs/developers/style-guide/#functors), если запутаетесь. Это также первый раз, когда мы видим пользовательскую схему SNARK. Для более подробной информации зайдите в раздел [пользовательская схема SNARK"](/docs/developers/style-guide/#snark-checked). 

## Приватный ключ

В разделе [private_key.ml] (https://github.com/minaprotocol/mina/tree/master/src/lib/signature_lib/private_key.ml) мы видим закрытый ключ `Tick.Inner_curve.Scalar.t` или скаляр на эллиптической кривой. Давайте разберем его точнее: Так как мы полагаемся на [рекурсивные zkSNARK](https://eprint.iacr.org/2014/595), то на самом деле у нас есть две эллиптические кривые `Tick` и `Tock`. Большая часть нашей логики происходит внутри `Tick` (TODO: @ihm expand on this). [Подписи Шнорра](#signature) требуют, чтобы мы использовали скаляры для нашего приватного ключа. 

## Открытый ключ

Открытый ключ, соответствующий [закрытому ключу] (#private-key) `p` - это просто $one^p$, или, другими словами, $one*one*one ....{p times}... one$. Мы можем увидеть это в [public_key.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/signature_lib/public_key.ml). Помните, что элементы группы являются ненулевыми точками кривой, поэтому мы также `include Non_zero_curve_point`.

Открытые ключи также можно сжимать -- см. [public_key.mli](https://github.com/minaprotocol/mina/tree/master/src/lib/signature_lib/public_key.mli). Точка на эллиптической кривой может быть однозначно представлена одним элементом скалярного поля и boolean. Это представление мы используем в [платежной нагрузке](#payment-payload), так как оно более эффективно внутри схем SNARK.

## Валюта

В [currency.mli](https://github.com/minaprotocol/mina/tree/master/src/lib/currency/currency.mli) мы определяем [номинальные типы](https://en.wikipedia.org/wiki/Nominal_type_system) комиссии, сумму и баланс, которые корректно обрабатывают overflow и underflow. На данный момент все поддерживается 64-битными беззнаковыми числами. Обратите внимание, что мы снова включаем операции схемы SNARK с [проверкой](#snark-checked) подмодулей внутри каждого из типов.

## Аккаунт

Платежи проводятся успешно только в том случае, если счет отправителя обладает определенными свойствами (и при этом баланс получателя не переполняется).

Согласно[account.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/mina_base/account.ml), аккаунт - это запись с [публичным ключом](#public-key) (владельца учетной записи), [балансом](#currency), [однократно используемым числом nonce](#account-nonce), и [хэшем цепи поступлений](#receipt-chainh-hash).

Платеж действителен, если:

1. Подпись соответствует w.r.t. открытого ключа отправителя.
2. Отправитель имеет достаточно средств, чтобы произвести выплату комиссионного вознаграждения и суммы.
3. У получателя достаточно места для суммы s.t. переполнения не будет.
4. Показатель [nonce аккаунта](#account-nonce) совпадает с показателем nonce внутри платежа.

Когда мы производим платеж, мы также сохраняем его в [цепочке получения] (#receipt-chain-hash), и при этом увеличиваем параметр account nonce.

Комиссии обрабатываются статически (см. систему превышения комиссии)(#fee-excess).

Это закодировано внутри SNARK в [transaction_snark.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/transaction_snark/transaction_snark.ml), а именно в функции `apply_tagged_transaction`, хотя вам придется посмотреть, как устанавливаются флаги bool в случае `is_normal`.

It's captured outside the SNARK here: (TODO: where is this? Staged_ledger somewhere?)

### Account Nonce

[Account_nonce.mli](https://github.com/minaprotocol/mina/tree/master/src/lib/mina_numbers/account_nonce.mli) - это просто [номинальный тип](https://en.wikipedia.org/wiki/Nominal_type_system) вокруг натурального числа. Это используется для защиты от двойного использования платежей.
Account nonce увеличивается в учетной записи отправителя всякий раз, когда платеж применен.

### Хэш цепи получения 

Хэш цепи [receipt.mli](https://github.com/minaprotocol/mina/tree/master/src/lib/mina_base/receipt.mli) является верхним хэшем [списка Меркла](#merkle-list) платежных нагрузок. Он используется, чтобы доказать, что вы на самом деле сделали платеж кому-то. Так как Mina не ведет историю платежей, это то, как вы можете доказать кому-то, что ваш платеж прошел.

Как это работает?

Лист Меркла подобен [дереву Меркла](https://en.wikipedia.org/wiki/Merkle_tree), но с одним ответвлением. До тех пор, пока вы храните хэши листа Меркла, вы можете доказать, что любой отдельный фрагмент данных был частью списка, если вы точно знаете, что такое верхний хэш.

Если важно доказать, что ваш платеж прошел, вы просите получателя начать записывать хеши цепочки получения, а также передаете ему вашу платежную нагрузку. Затем он может проверить верхний хэш своей цепочки получения, чтобы узнать, включает ли он вашу платежную нагрузку.

## Сделайте перерыв!

Мы полностью описали все компоненты `Payment.t`. Поздравляем с тем, что вы зашли так далеко!

После перерыва мы будем готовы погрузиться в код daemon.

## Daemon

Daemon Mina определен в строке [mina.ml](https://github.com/minaprotocol/mina/tree/master/src/app/cli/src/mina.ml). Ищите функцию `daemon`, чтобы увидеть CLI-флаги, которые мы там используем. Клиент может опционально автоматически запускать Daemon, если он уже существует. Мы получаем конфигурацию из конфигурационного файла JSON (попробуйте сначала из `-f`, затем из `$XDG_CONFIG_DIR/mina/daemon.json`, затем из `/etc/mina/daemon.json`). Перед этим мы производим множество настроек, которые приводят к вызову `Mina_main.Mina.Make`, а затем запускаем его командой `Run`. Подробности описаны ниже.

Имея модуль `Run`, мы можем создать экземпляр mina daemon на уровне значений, а также настроить любые фоновые процессы и сервисы.

## Main

К тому времени, как вы это читаете, надеемся, вам уже удалось приручить зверя, которым является [mina_main.ml](https://github.com/minaprotocol/mina/tree/master/src/app/cli/src/mina_main.ml). Здесь мы соединяем систему на модульном уровне. Что это значит? Мы инстанцируем все функторы для различных подкомпонентов daemon. В конце концов, мы создаем что-то, что соответствует `Main_intf` (в этом же файле).

### Запуск функтора

В конце [mina_main.ml] (https://github.com/minaprotocol/mina/tree/master/src/app/cli/src/mina_main.ml) мы определяем функтор `Run`, который, наконец, имеет другую сторону вызова `rpc`, который клиент осуществляет для `send_payment`. Run содержит исполнение на стороне сервера всех вызовов RPC, которые делает клиент. Он также отвечает за логику настройки любых RPC/веб-серверов и фоновых процессов.

Давайте предположим, что у нас есть уже созданный экземпляр `Run.t`, и мы вернемся к нему позже.

### Client_rpc

In [daemon_rpcs.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/daemon_rpcs/daemon_rpcs.ml), we define the concrete RPC calls that the client uses to communicate to the daemon. We use [Async](https://opensource.janestreet.com/async/)'s RPC library for this. `Send_payments` defined the RPC call we use to send the payment: the query type is the input -- the payments we want to send -- and the response is the output -- in this case `unit`, because we don't get any meaningful feedback other than "the payment has been enqueued" on success.

### Schedule payment into Transaction pool

Back in [mina_main.ml](https://github.com/minaprotocol/mina/tree/master/src/app/cli/src/mina_main.ml), we invoke `send_payment` in [Run](#run), that delegates to `schedule_payment` -- here we enqueue the payment into the [Transaction Pool](#transaction-pool).

## Mina_lib

To create a `Run` instance we'll need to go to [mina_lib.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/mina_lib/mina_lib.ml) where we wire all subsystems together at the value level. This is in contrast to [mina_main.ml](#main) where we wire all the subsystems together at the module level.

It's here where we can trace the path of the payment from the transaction pool forwards. Let's sketch that out before diving deeper into each of the subsystems:

1. The [transaction pool](#transaction-pool) broadcasts diffs from the transaction pool through to the [network](#network)
2. The [proposer](#proposer) reads payments from the transaction pool when it's time to make a transition from one blockchain state to another, those payments are part of a diff to update a [staged-ledger](#staged-ledger) which is committed to inside the new blockchain state. [External transitions](#external-transition) are emitted.
3. The [network](#network) and the [proposer](#proposer) feed [external transitions](#external-transition) containing information on how to update a [staged-ledger](#staged-ledger) with the new payment buffered to the [ledger builder controller](#ledger-builder-controller)
4. The [ledger builder controller](#ledger-builder-controller) figures out where this [external transition](#external-transition) fits in it's tree of possible forks. If this happens to extend our "best" path (the state upon which we will propose later) then we do an expensive materialization step to create a [tip](#tip) holding the new [staged ledger](#staged-ledger) and emit this strongest tip over the [network](#network). Healthy clients only forward tips they locally think are the strongest.

## Transaction Pool

Open up [transaction_pool.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/transaction_poll/transaction_pool.ml)... TODO

## Network

TODO

## Proposer

TODO

## External Transition

TODO

## Ledger-builder-controller

TODO

## Staged-ledger

A staged ledger can be regarded as a "Pending accounts database" that has transactions(payments, coinbase, and proof-fees) applied for which there are no snarks available yet.
A staged ledger consists of the accounts state (what we currently call ledger) and a data structure called [parallel_scan.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/parallel_scan/parallel_scan.ml). It keeps track of all the transactions that need to be snarked (grep for `Available_job.t`) to produce a single transaction snark that certifies a set of transactions. This is exposed as Aux in the staged ledger.
Parallel scan is a tree like structure that stores statements needed to be proved. A statement can be of applying a single transaction `Base` or of composing other statements `Merge`. Snarking of these statements is delegated to snark-workers. The snark workers submit snarks for the corresponding statements which are used by the proposer to update the parallel scan state.

When the propser wins a block, the payments read from the transaction pool are sent to the staged ledger to create a diff `Staged_ledger_diff`.
A diff consists of

1. Payments included in the block
2. A list of proofs that prove some of the transactions (payments, coinbase, and proof-fees) from previous blocks
3. Coinbase

There are two primary operations in staged ledger.

1. Creating a diff :
   To include a payment from the transaction pool, the proposer needs to include snarks generated by its own snark-workers (or buy it from someone) which certifies some of the transactions added in previous blocks. The number of snarks needs to be twice the number of transactions being included in the block (an invariant of the aux data structure). These proofs are included in the diff along with the payments and coinbase.
   The diff is then included in the external transition and broadcasted to the network.

2. Applying a diff: Diffs from the node itself (Internal transitions) or from the network (External transitions) are then used to update the staged ledger by applying the payments to the ledger and updating the parallel scan state with the proofs. Applying a diff may produce a proof for a sequence of transactions that were included in the previous blocks.

## Ledger

TODO
