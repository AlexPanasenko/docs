import Page from "@reason/pages/Docs";
export default Page({ title: "Consensus Mechanism Abstraction" });

# Абстракция Механизма Консенсуса

Консенсус относится к процессу, посредством которого сеть определяет, какая информация будет сохраняться в блокчейне. В такой системе, как блокчейн, ответственность за расширение цепи за счет поступающей новой информации распределяется между всеми участвующими нодами сети. Эти ноды не могут считаться "честными" нодами, и поэтому "честные" участники сети должны работать вместе, чтобы выбрать, какая информация, предлагаемая различными нодами, будет в итоге сохранена. Существует много различных способов достижения распределенного консенсуса, которые мы называем "механизмами консенсуса". В нашей кодовой базе мы построили единый интерфейс, с помощью которого механизм консенсуса информирует остальную часть протокола. Через этот интерфейс различные реализации механизмов консенсуса могут быть заменены во время компиляции, чтобы мы могли написать остальную часть протокола независимо от выбранного консенсусного механизма. Таким образом, можно думать о механизме консенсуса как о чем-то таком, на чем можно построить остальную часть протокола сразу, как только этот механизм определен.

Механизм консенсуса контролирует многие аспекты в протоколе, который построен на его основе. Для целей данного обсуждения мы разделим положения механизма консенсуса на две части: данные (структуры данных и доступные взаимодействия с ними) и хуки (специфические хуки верхнего уровня, предусмотренные протоколом, построенным поверх механизма консенсуса). Структуры данных, предоставляемые механизмом консенсуса, остаются абстрактными для внешней системы, взаимодействующей с ними, и вместо этого в первую очередь используются "хуки" механизма консенсуса.

!!! примечание
Этот документ охватывает только обобщенную абстракцию механизма консенсуса в Mina. Для получения информации о реализации механизма Proof of Stake в Mina, [см. соответствующую документацию] (/docs/architecture/proof-of-stake).

## Данные

### Local_state

`Local_state` это состояние, связанное с консенсусом, которое сохраняется исключительно локально на машине. Оно обеспечивает место для консенсуса, чтобы отслеживать некоторую информацию о локальной ноде в конечных точках состояния протокола. Смотрите хук `frontier_root_transition` для более подробной информации о том, как

### Consensus_transition_data

`Consensus_transition_data` является частью состояния, которое включено в `Snark_transition`. Она обеспечивает возможность для достижения консенсуса при добавлении дополнительной информации, которая будет доказана SNARK для доказательства перехода. В отличие от `Consensus_state`, информация в `Consensus_transition_data` используется только нодой, которая создает переход, и не доступна другим нодам.

### Consensus_state

`Consensus_state` включено в `Protocol_state` протокола. Обеспечивает место для механизма консенсуса с целью хранения информации, которая доступна в каждом состоянии протокола и может быть доказана в snark. Так как она включена в `Protocol_state`, то эта информация может быть проверена другими узлами сети.

### Prover_state

**TODO**

### Proposal_data

**TODO**

#### Other Instantiated Data

- `Blockchain_state`
- `Protocol_state`
- `Snark_transition`

## Хуки

[hooks]: #hooks

<!-- ![](res/consensus_hooks.dot.png) -->

### generate_transition

Хук `generate_transition` генерирует состояние нового протокола и данные перехода консенсуса как расширение предыдущего состояния протокола на блокчейн. Для этой функции предусмотрено новое состояние блокчейна, а также транзакции, подлежащие включению в дифф распределенного реестра и соответствующие предлагаемые данные. Этот хук должен быть вызван тем, кто его предложил, с best tip на границе на данный момент в качестве `previous_protocol_state`. Автор предложения должен взаимодействовать с хуком `next_protocol_state`, чтобы определить, когда этот хук будет вызван.

### next_proposal

The `next_proposal` hook informs the protocol when it is valid to generate and propose the next transition. This hook may either return a time to propose a transition at, or a time to check the hook again. This allows a consensus mechanism to space out proposals, as well as control more advanced scheduling of proposals based on other information in the protocol.

<!-- <sup>_For more information on how the `next_proposal` hook interacts the `Proposer`, see the [`Proposer` documentation](proposer.md#proposal-scheduling)._</sup> -->

### next_state_checked

The `next_state_checked` hook returns a checked computation which calculates/constrains the next consensus state in a blockchain sequence given its predecessor's transition. This hook is included into the checked computation which makes up the blockchain snark constraint system. As such, this is the primary function in which validation is performed on consensus states.

### select

The `select` hook informs the protocol that, given two states, which state is "better" in the eyes of the consensus mechanism. This hook plays a vital role in how consensus is achieved, as it is the primary operation which determines, between two chains, which should be kept. When called, it will inform the caller to either `Keep` the existing state, or to `Take` the candidate state.

### received_at_valid_time

The `received_at_valid_time` hook is a predicate on whether or not a given consensus state is valid at a given time. This lets the consensus mechanism optionally control temporal properties of when a consensus state was valid to generate, rejecting the received protocol state if it was recieved out of band. The implementation of the protocol should call this hook whenever a transition is received from the network, before processing the transition and adding it to the frontier.

### frontier_root_transition

The `frontier_root_transition` hook needs to be called whenever a transition occurs at the point of finality (in mina, this is the root of the transition frontier). This provides a chance for the consensus mechanism to update its local state in accordance with the network's finalized state.

### should_bootstrap

The `should_bootstrap` hook informs the protocol whether or not a transition received over the network requires the node to begin bootstrapping its state to the current network state. The consensus mechanism determines how long it will take until state finalization, and whether or not a node should bootstrap is also connected to this concept. This hook should be called whenever a transition is received from the network and initial validation is performed successfully.
