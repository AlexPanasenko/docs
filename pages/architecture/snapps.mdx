import Page from "@reason/pages/Docs";
export default Page({ title: "Snapps: SNARK Powered Applications" });

# Snapps: Приложения на базе SNARK

<Alert kind="warning">

  На момент релиза `0.0.16-beta7` эта функция была отключена и может быть использована только при включенном флаге сборки. Мы планируем включить эту функцию в будущих версиях.

</Alert>

### Snapps = Dapps + Конфиденциальность + Офчейн-данные + Масштабируемость

Mina, как самый легкий блокчейн в мире, открывает совершенно новую категорию приложений под названием Snapps <Footnote refNumber="[3]" link="/disclaimers" />: Snark-приложения. Snapps функционально похожи на Dapps, созданные на базе Ethereum, но превосходят их благодаря трем специфическим свойствам:

1. Проверка целостности части данных без раскрытия их содержания.
2. Проверка правильности проведения дорогостоящих операций.
3. Значительные преимущества с точки зрения масштабируемости.

Подобные типы приложений не обязательно являются новыми - в каком-то смысле они существуют в виде современных блокчейнов: например, zCash как Snapp со свойством 1, или Mina в качестве Snapp со свойством 2.

Snapp также значительно эффективнее, чем Dapp на Ethereum. Так, чтобы сеть Ethereum могла предоставить своим пользователям возможность использования Dapp, все ноды и майнеры в сети должны выполнять одинаковые вычисления. Это крайне неэффективно. Snapp на Mina выполняется один раз самим разработчиком, после чего все остальные ноды могут просто проверить связанное с ним доказательство SNARK. Тот же аргумент можно привести и для SNARK, работающих на 2-м уровне Dapps на Ethereum. Однако эти Dapps все еще ограничены в производительности основной цепи, тогда как Snapp на блокчейне Mina выигрывает в потенциале масштабирования благодаря своей компактности.

В целом, Snapp на базе Mina имеет следующий принцип работы:

1. Определение кода для запуска, открытие исходного кода, если он не был открыт до этого
2. Использование кода для развертывания контура SNARK путем функции вызова на Mina
3. Включение источника данных для выполнения операции
4. Вызов функции с соответствующими данными
5. Проведение операции ончейн, аналогично смарт-контракту [будет готово через 6-12 месяцев после запуска основной сети]
6. Прикрепление SNARK-доказательства, вернувшегося от функции на адрес Mina
7. Mina проводит транзакцию на основании SNARK-доказательства


## Технический обзор

В нынешнем виде функционал Snapps от Mina будет работать следующим образом.

- Появится новый вид аккаунтов, называемых "Snapp account", которые, помимо открытого ключа и баланса, будут содержать также верификационную клавишу Pickles SNARK K и статус S, состоящий из небольшого массива элементов поля.
- Появится новый вид транзакций под названием "Однократная Snapp-транзакция". Они позволят осуществлять переводы на стандартный счет и с него, а также обновлять состояние Snapp. Она будет содержать


  - Адрес стандартного счёта
  - Адрес Snapp-счёта
  - Подписываемую сумму "snapp_account_delta", которая представляет собой изменение в балансе Snapp-счета.
  - Опционально предлагаемое новое состояние "snapp_new_state" для Snapp-счета.
  - Если значение "snapp_acount_delta" > 0, то подпись на транзакции производится со стандартного счета
  - Доказательство Pickles SNARK, которое должно быть проверено (с помощью верификационного ключа для счетов Snapp) на основании выписки, включая
    - snapp_account_delta : SignedAmount
    - snapp_prev_state : Array&lt;Field>
    - snapp_new_state : Array&lt;Field>

  Результат применения данной транзакции будет заключаться в обновлении состояния Snapp согласно заданным параметрам, изменении баланса Snapp по команде snapp_acount_delta, и изменении баланса стандартного аккаунта по команде -snapp_account_delta.

- Появится новый вид транзакций под названием "Двойная транзакция Snapp". Это позволит одновременно обновлять состояния на двух счетах Snapp (и переводить средства между ними).
- Она будет содержать

  - Адрес Snapp-счёта "адрес1".
  - Адрес Snapp-счета "адрес2".
  - Подписанную сумму "account1_delta", которая представляет собой изменение остатка на первом счете.
  - Два опционально предлагаемых новых состояния "account1_new_state" и "account2_new_state"
  - Если snapp_acount_delta > 0, то подпись на транзакцию производится со стандартного счета
  - Два Pickles SNARK доказательства "доказательство1", "доказательство2", которые для i = 1, 2 должны быть подтверждены (с помощью верификационного ключа учетной записи) на основании выписки, в том числе
    - account1_delta : SignedAmount
    - account1_prev_state : Array&lt;Field>
    - account1_new_state : Array&lt;Field>
    - account2_prev_state : Array&lt;Field>
    - account2_new_state : Array&lt;Field>

  Итогами такой операции будут: обновление состояния обоих счетов согласно заданным параметрам, изменение баланса счета1 путем добавления параметра - account1_delta, и изменение остатка счета2 путем добавления параметра - account1_delta.

O(1) Labs is currently developing tooling for app developers, which includes existing ones like [snarky](https://github.com/o1-labs/snarky), to easily develop Snapps, and with the click of a button compute required SNARK proofs. The tooling will be compatible with Mina out of the box, providing Snapps with an easy way to gain state and financial value.

Let’s dive into a couple examples that will showcase the true power of Snapps.

## Examples

### Example 1: Proof of Credit Score

**Value Proposition: **Providing borrowers with a way to prove their credit score is above a certain threshold, without disclosing the score itself, and thus be able to borrow funds without posting any collateral.

**Example User Flow:**

- User visits website of lender
- Is asked to download cryptographically signed information from a credit score provider such as CreditKarma
- Website locally checks if credit score is above threshold and computes SNARK proof returning the result
- SNARK proof and result are attached to the Mina address of the user and is shared with the cloud system of the lender (could also be a smart contract)
- Lender verifies the SNARK proof and passing of threshold
- Loan is provided to the Mina address in stablecoins, if it meets criteria

**How Snapp Toolset Is Used: **Developer of Snapp uses the toolset to integrate a specific program that has the user download a signed credit score from provider, check locally on the user’s computer that the score meets criteria, and locally generate a proof for the check, which is subsequently shared back with the developer. The toolset also provides the user with a Mina address behind the scenes, which is used to provide a time stamp to the computation via the block number on the Mina blockchain. They also use the toolset to integrate a SNARK verifier into their own backend to confirm the validity of the local computation.

### Example 2: Proof of Authentic Identity Document

**Value Proposition: **Proving that the owner of a Mina address has access to an authentic identity document (such as driver’s license), without disclosing the document itself, starting with a certain block height. The validity of the identity document would be checked by a standardized open source algorithm.

**Example User Flow:**

- User visits website, downloads app to laptop or mobile phone
- Uses app to scan ID, verify its authenticity
- App also creates Mina wallet for user
- App associates SNARK proof with Mina address of user, along with hash of the photo of the ID
- User visits another website that asks for authentic identity. Is able to share the ID proof, along with a hash of their ID, to confirm their Mina address has claim over an authentic ID

**How Snapp Toolset Is Used: **Snapp toolset provides the developer with an SDK to embed into their app the SNARK proof generator and hash generator, along with a Mina interface. Snapp toolset also provides any other developer that wants to be able to verify said ID authentications with a SNARK verifier.

### Example 3: Proof of Coinbase Balance

**Value Proposition: **Providing third parties with proof of funds meeting a certain criteria (e.g. >\$10,000) in a Coinbase account belonging to a specific email, without disclosing the actual deposit amount.

**Example User Flow:**

- User visits a lending application. In order to borrow funds, they’re asked to have at least >\$10,000 of Bitcoin in their Coinbase account.
- User OAuths into their Coinbase account
- The website locally checks user’s balance and email, both signed by Coinbase’s keys
- Website locally generates SNARK proof that user’s balance is >\$10,000
- SNARK proof is attached to the Mina address of the user
- User signs their ownership of the SNARK proof using their Mina address, and shares the email address of their Coinbase account with the backend of the lending application.

**How Snapp Toolset Is Used: **Developer of Snapp uses the toolset to integrate a specific program that has the user OAuth into their Coinbase account, query their account balance for a signed balance information, the account’s email address, and a time stamp. The toolset allows a SNARK proof to be generated locally, without sharing any information with the backend of the service provider, so all balance info stays private. The developer also uses the toolset to integrate a SNARK verifier into their own backend to confirm the validity of the local computation.

### Example 4: Private Voting

**Value Proposition:** Allowing a set of eligible voters (e.g. any Twitter account with >100 followers) to vote privately, without disclosing who they are and what they voted for. Anyone would easily be able to verify the outcome of the entire vote once the voting period is over.

**Example User Flow:**

- User can prove ownership of a given account by exhibiting the HTTPS transcript of them successfully logging into twitter.com. To authenticate and vote, they will prove (public input in orange), “I know an account A with password P and a valid login transcript for (A, P) and hash(A, P) = **N** and my vote is for option **V**”. **N** is called a “nullifier” and is unique to a given user/password combination and is used to prevent double voting.
- In a fully decentralized mode, the user can then use this proof to update the state of the election app on the Mina chain.
- In a higher throughput, partially decentralized mode, the user would send their zero knowledge proof to a proof-aggregator, who maintains the state of the election, and aggregates the user proofs together into one bundled together proof, which then gets posted to the Mina chain.
- When viewing the results of the election, the user obtains the main Mina blockchain proof, which certifies the validity of the entire Mina merkle tree, including the leaf corresponding to the election state. They also obtain a merkle path into this leaf so that they can view the state.

### Other Ideas

The design space for Snapps is huge, and will consist of many other innovative ideas entrepreneurs will come up with as the framework is better understood. Some other examples we have thought of:

- Proof of age using identity document
- Proof of citizenship using identity document
- Proof of salary via bank account
- Proof of not doing an activity, e.g. blockchain address associated with a specific identity has not sent money to blacklisted wallet addresses, without disclosing address
- Proof of limited alterations to a document, e.g. resizing a validated photo

## Next Steps and Community Involvement

O(1) Labs is working hard to build the Snapp toolset which will make the above examples possible on the Mina blockchain, and partner with talented developers to build the first proof of concept implementations.

However, the sky's the limit for Snapps. As such, we would like to invite the Mina community to join us in ideating different Snapp use cases and user flows, as well as helping us develop the tools and apps by contributing to the code. If you would like to join the exploration of this entirely new design space for confidential and verifiable applications, start by filling out this [form](https://forms.gle/PsM1AmZMveE3RhaV8).
